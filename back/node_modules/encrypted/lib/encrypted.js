"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "decodeUTF8", {
  enumerable: true,
  get: function get() {
    return _tweetnaclUtil.decodeUTF8;
  }
});
Object.defineProperty(exports, "encodeUTF8", {
  enumerable: true,
  get: function get() {
    return _tweetnaclUtil.encodeUTF8;
  }
});
Object.defineProperty(exports, "encodeBase64", {
  enumerable: true,
  get: function get() {
    return _tweetnaclUtil.encodeBase64;
  }
});
Object.defineProperty(exports, "decodeBase64", {
  enumerable: true,
  get: function get() {
    return _tweetnaclUtil.decodeBase64;
  }
});
exports.decrypted = exports.encrypted = exports.decrypt = exports.encrypt = exports.generateKey = exports.newRandomSalt = void 0;

var _tweetnacl = require("tweetnacl");

var _tweetnaclUtil = require("tweetnacl-util");

var _scryptAsync = _interopRequireDefault(require("scrypt-async"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var newNonce = function newNonce() {
  return (0, _tweetnacl.randomBytes)(_tweetnacl.secretbox.nonceLength);
};

var newRandomSalt = function newRandomSalt() {
  return (0, _tweetnaclUtil.encodeBase64)((0, _tweetnacl.randomBytes)(_tweetnacl.secretbox.nonceLength));
};

exports.newRandomSalt = newRandomSalt;
var latestScryptOptions = {
  N: 16384,
  r: 8,
  p: 1,
  dkLen: _tweetnacl.secretbox.keyLength,
  interruptStep: 0
};

var generateKey = function generateKey(password, salt) {
  var scryptOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : latestScryptOptions;
  return new Promise(function (resolve) {
    (0, _scryptAsync["default"])( //@ts-ignore
    password, salt, _objectSpread(_objectSpread({}, scryptOpts), {}, {
      encoding: "binary"
    }), function (derivedKey) {
      resolve(derivedKey);
    });
  });
};

exports.generateKey = generateKey;

var getUint8ArrayKeyFromOpts = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(opts) {
    var password, salt, key;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            password = opts.password, salt = opts.salt;
            key = opts.key;

            if (!(!key && password && salt)) {
              _context.next = 6;
              break;
            }

            _context.next = 5;
            return generateKey(password, salt, opts.scrypt);

          case 5:
            return _context.abrupt("return", _context.sent);

          case 6:
            if (key) {
              _context.next = 8;
              break;
            }

            throw new Error("A key, or a password/salt to generate a key from, is required!");

          case 8:
            if (typeof key === "string") {
              key = (0, _tweetnaclUtil.decodeUTF8)(key);
            }

            return _context.abrupt("return", key);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getUint8ArrayKeyFromOpts(_x) {
    return _ref.apply(this, arguments);
  };
}();

var encrypt = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(obj, secretOpts) {
    var nonce, keyUint8Array, messageUint8, box, fullMessage;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            nonce = secretOpts.nonce || newNonce();

            if (!(nonce.length !== _tweetnacl.secretbox.nonceLength)) {
              _context2.next = 3;
              break;
            }

            throw new Error("Invalid nonce, must be a Uint8Array of length ".concat(_tweetnacl.secretbox.nonceLength));

          case 3:
            _context2.next = 5;
            return getUint8ArrayKeyFromOpts(secretOpts);

          case 5:
            keyUint8Array = _context2.sent;
            messageUint8 = (0, _tweetnaclUtil.decodeUTF8)(JSON.stringify(obj));
            box = (0, _tweetnacl.secretbox)(messageUint8, nonce, keyUint8Array);
            fullMessage = new Uint8Array(nonce.length + box.length);
            fullMessage.set(nonce);
            fullMessage.set(box, nonce.length);
            return _context2.abrupt("return", (0, _tweetnaclUtil.encodeBase64)(fullMessage));

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function encrypt(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();

exports.encrypt = encrypt;

var decrypt = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(messageWithNonce, secretOpts) {
    var keyUint8Array, messageWithNonceAsUint8Array, nonce, message, decryptedData, base64DecryptedMessage;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getUint8ArrayKeyFromOpts(secretOpts);

          case 2:
            keyUint8Array = _context3.sent;
            messageWithNonceAsUint8Array = (0, _tweetnaclUtil.decodeBase64)(messageWithNonce);
            nonce = messageWithNonceAsUint8Array.slice(0, _tweetnacl.secretbox.nonceLength);
            message = messageWithNonceAsUint8Array.slice(_tweetnacl.secretbox.nonceLength, messageWithNonce.length);
            decryptedData = _tweetnacl.secretbox.open(message, nonce, keyUint8Array);

            if (decryptedData) {
              _context3.next = 9;
              break;
            }

            throw new Error("Could not decrypt message");

          case 9:
            base64DecryptedMessage = (0, _tweetnaclUtil.encodeUTF8)(decryptedData);
            return _context3.abrupt("return", JSON.parse(base64DecryptedMessage));

          case 11:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function decrypt(_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();

exports.decrypt = decrypt;

var encrypted = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(data, secretOpts) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (typeof secretOpts.salt !== "string") {
              secretOpts.salt = newRandomSalt();
            }

            if (!(secretOpts.type === "plaintext")) {
              _context4.next = 5;
              break;
            }

            return _context4.abrupt("return", {
              encryption: {
                type: "plaintext"
              },
              data: data
            });

          case 5:
            // default is using secretbox
            secretOpts.nonce = newNonce();
            _context4.t0 = {
              type: "secretbox",
              salt: secretOpts.salt,
              nonce: (0, _tweetnaclUtil.encodeBase64)(secretOpts.nonce),
              scrypt: _objectSpread({}, latestScryptOptions)
            };
            _context4.next = 9;
            return encrypt(data, secretOpts);

          case 9:
            _context4.t1 = _context4.sent;
            return _context4.abrupt("return", {
              encryption: _context4.t0,
              data: _context4.t1
            });

          case 11:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function encrypted(_x6, _x7) {
    return _ref4.apply(this, arguments);
  };
}();

exports.encrypted = encrypted;

var decrypted = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(encryptedData, secretOpts) {
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!(encryptedData.encryption.type === "secretbox")) {
              _context5.next = 4;
              break;
            }

            return _context5.abrupt("return", decrypt(encryptedData.data, {
              salt: encryptedData.encryption.salt,
              password: secretOpts.password,
              key: secretOpts.key,
              scrypt: encryptedData.encryption.scrypt
            }));

          case 4:
            return _context5.abrupt("return", encryptedData.data);

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function decrypted(_x8, _x9) {
    return _ref5.apply(this, arguments);
  };
}();

exports.decrypted = decrypted;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lbmNyeXB0ZWQudHMiXSwibmFtZXMiOlsibmV3Tm9uY2UiLCJzZWNyZXRib3giLCJub25jZUxlbmd0aCIsIm5ld1JhbmRvbVNhbHQiLCJsYXRlc3RTY3J5cHRPcHRpb25zIiwiTiIsInIiLCJwIiwiZGtMZW4iLCJrZXlMZW5ndGgiLCJpbnRlcnJ1cHRTdGVwIiwiZ2VuZXJhdGVLZXkiLCJwYXNzd29yZCIsInNhbHQiLCJzY3J5cHRPcHRzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJlbmNvZGluZyIsImRlcml2ZWRLZXkiLCJnZXRVaW50OEFycmF5S2V5RnJvbU9wdHMiLCJvcHRzIiwia2V5Iiwic2NyeXB0IiwiRXJyb3IiLCJlbmNyeXB0Iiwib2JqIiwic2VjcmV0T3B0cyIsIm5vbmNlIiwibGVuZ3RoIiwia2V5VWludDhBcnJheSIsIm1lc3NhZ2VVaW50OCIsIkpTT04iLCJzdHJpbmdpZnkiLCJib3giLCJmdWxsTWVzc2FnZSIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJkZWNyeXB0IiwibWVzc2FnZVdpdGhOb25jZSIsIm1lc3NhZ2VXaXRoTm9uY2VBc1VpbnQ4QXJyYXkiLCJzbGljZSIsIm1lc3NhZ2UiLCJkZWNyeXB0ZWREYXRhIiwib3BlbiIsImJhc2U2NERlY3J5cHRlZE1lc3NhZ2UiLCJwYXJzZSIsImVuY3J5cHRlZCIsImRhdGEiLCJ0eXBlIiwiZW5jcnlwdGlvbiIsImRlY3J5cHRlZCIsImVuY3J5cHRlZERhdGEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7QUFvREEsSUFBTUEsUUFBUSxHQUFHLFNBQVhBLFFBQVc7QUFBQSxTQUFNLDRCQUFZQyxxQkFBVUMsV0FBdEIsQ0FBTjtBQUFBLENBQWpCOztBQUVPLElBQU1DLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0I7QUFBQSxTQUMzQixpQ0FBYSw0QkFBWUYscUJBQVVDLFdBQXRCLENBQWIsQ0FEMkI7QUFB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RCxjQUFBQSxRQUFRLEVBQUVjLFVBQVUsQ0FBQ2QsUUFGc0I7QUFHM0NTLGNBQUFBLEdBQUcsRUFBRUssVUFBVSxDQUFDTCxHQUgyQjtBQUkzQ0MsY0FBQUEsTUFBTSxFQUFFNkIsYUFBYSxDQUFDRixVQUFkLENBQXlCM0I7QUFKVSxhQUEvQixDQUxPOztBQUFBO0FBQUEsOENBWWQ2QixhQUFhLENBQUNKLElBWkE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBSDs7QUFBQSxrQkFBVEcsU0FBUztBQUFBO0FBQUE7QUFBQSxHQUFmIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VjcmV0Ym94LCByYW5kb21CeXRlcyB9IGZyb20gXCJ0d2VldG5hY2xcIjtcbmltcG9ydCB7XG4gIGRlY29kZVVURjgsXG4gIGVuY29kZVVURjgsXG4gIGVuY29kZUJhc2U2NCxcbiAgZGVjb2RlQmFzZTY0LFxufSBmcm9tIFwidHdlZXRuYWNsLXV0aWxcIjtcbmltcG9ydCBzY3J5cHQsIHsgT3B0aW9ucyBhcyBTY3J5cHRPcHRpb25zIH0gZnJvbSBcInNjcnlwdC1hc3luY1wiO1xuXG5leHBvcnQgeyBkZWNvZGVVVEY4LCBlbmNvZGVVVEY4LCBlbmNvZGVCYXNlNjQsIGRlY29kZUJhc2U2NCB9O1xuXG50eXBlIEpzb24gPVxuICB8IG51bGxcbiAgfCBib29sZWFuXG4gIHwgbnVtYmVyXG4gIHwgc3RyaW5nXG4gIHwgSnNvbltdXG4gIHwgeyBbcHJvcDogc3RyaW5nXTogSnNvbiB9O1xuXG50eXBlIEpzb25Db21wYXRpYmxlPFQ+ID0ge1xuICBbUCBpbiBrZXlvZiBUXTogVFtQXSBleHRlbmRzIEpzb25cbiAgICA/IFRbUF1cbiAgICA6IFBpY2s8VCwgUD4gZXh0ZW5kcyBSZXF1aXJlZDxQaWNrPFQsIFA+PlxuICAgID8gbmV2ZXJcbiAgICA6IFRbUF0gZXh0ZW5kcyAoKCkgPT4gYW55KSB8IHVuZGVmaW5lZFxuICAgID8gbmV2ZXJcbiAgICA6IEpzb25Db21wYXRpYmxlPFRbUF0+O1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBTZWNyZXRib3hFbmNyeXB0aW9uT3B0aW9ucyB7XG4gIHNhbHQ6IHN0cmluZztcbiAgdHlwZTogXCJzZWNyZXRib3hcIjtcbiAgc2NyeXB0OiBTY3J5cHRPcHRpb25zO1xufVxuZXhwb3J0IGludGVyZmFjZSBQbGFpbnRleHRFbmNyeXB0aW9uT3B0aW9ucyB7XG4gIHR5cGU6IFwicGxhaW50ZXh0XCI7XG59XG5cbmV4cG9ydCB0eXBlIEVuY3J5cHRhYmxlRGF0YSA9IEpzb25Db21wYXRpYmxlPGFueT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW5jcnlwdGVkRG9jdW1lbnQ8RW5jcnlwdGlvbk9wdGlvbnMsIERhdGFUeXBlPiB7XG4gIGVuY3J5cHRpb246IEVuY3J5cHRpb25PcHRpb25zO1xuICBkYXRhOiBEYXRhVHlwZTsgLy8gd2lsbCBiZSBhIHN0cmluZyB3aGVuIGVuY3J5cHRlZFxufVxuXG5leHBvcnQgdHlwZSBTZWNyZXRib3hFbmNyeXB0ZWREb2N1bWVudCA9IEVuY3J5cHRlZERvY3VtZW50PFxuICBTZWNyZXRib3hFbmNyeXB0aW9uT3B0aW9ucyxcbiAgc3RyaW5nXG4+O1xuLy8gbm90IGVuY3J5cHRlZC4uLlxuZXhwb3J0IHR5cGUgUGxhaW50ZXh0RG9jdW1lbnQgPSBFbmNyeXB0ZWREb2N1bWVudDxcbiAgUGxhaW50ZXh0RW5jcnlwdGlvbk9wdGlvbnMsXG4gIEVuY3J5cHRhYmxlRGF0YVxuPjtcblxuZXhwb3J0IHR5cGUgTWF5YmVFbmNyeXB0ZWREb2N1bWVudCA9XG4gIHwgU2VjcmV0Ym94RW5jcnlwdGVkRG9jdW1lbnRcbiAgfCBQbGFpbnRleHREb2N1bWVudDtcblxuY29uc3QgbmV3Tm9uY2UgPSAoKSA9PiByYW5kb21CeXRlcyhzZWNyZXRib3gubm9uY2VMZW5ndGgpO1xuXG5leHBvcnQgY29uc3QgbmV3UmFuZG9tU2FsdCA9ICgpID0+XG4gIGVuY29kZUJhc2U2NChyYW5kb21CeXRlcyhzZWNyZXRib3gubm9uY2VMZW5ndGgpKTtcblxuY29uc3QgbGF0ZXN0U2NyeXB0T3B0aW9ucyA9IHtcbiAgTjogMTYzODQsXG4gIHI6IDgsXG4gIHA6IDEsXG4gIGRrTGVuOiBzZWNyZXRib3gua2V5TGVuZ3RoLFxuICBpbnRlcnJ1cHRTdGVwOiAwLFxufTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlS2V5ID0gKFxuICBwYXNzd29yZDogc3RyaW5nLFxuICBzYWx0OiBzdHJpbmcsXG4gIHNjcnlwdE9wdHM6IFNjcnlwdE9wdGlvbnMgPSBsYXRlc3RTY3J5cHRPcHRpb25zXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc2NyeXB0KFxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHNhbHQsXG4gICAgICB7XG4gICAgICAgIC4uLnNjcnlwdE9wdHMsXG4gICAgICAgIGVuY29kaW5nOiBcImJpbmFyeVwiLFxuICAgICAgfSBhcyBTY3J5cHRPcHRpb25zLFxuICAgICAgZnVuY3Rpb24gKGRlcml2ZWRLZXk6IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmVzb2x2ZShkZXJpdmVkS2V5KTtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VjcmV0T3B0aW9ucyB7XG4gIHNhbHQ/OiBzdHJpbmcgfCBudWxsO1xuICBwYXNzd29yZD86IHN0cmluZyB8IG51bGw7XG4gIGtleT86IG51bGwgfCBzdHJpbmcgfCBVaW50OEFycmF5O1xuICBub25jZT86IFVpbnQ4QXJyYXk7XG4gIHNjcnlwdD86IFNjcnlwdE9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW5jcnlwdGVkT3B0aW9ucyBleHRlbmRzIFNlY3JldE9wdGlvbnMge1xuICB0eXBlPzogXCJzZWNyZXRib3hcIiB8IFwicGxhaW50ZXh0XCI7XG59XG5cbmNvbnN0IGdldFVpbnQ4QXJyYXlLZXlGcm9tT3B0cyA9IGFzeW5jIChcbiAgb3B0czogU2VjcmV0T3B0aW9uc1xuKTogUHJvbWlzZTxVaW50OEFycmF5PiA9PiB7XG4gIGNvbnN0IHsgcGFzc3dvcmQsIHNhbHQgfSA9IG9wdHM7XG4gIGxldCB7IGtleSB9ID0gb3B0cztcblxuICBpZiAoIWtleSAmJiBwYXNzd29yZCAmJiBzYWx0KSB7XG4gICAgcmV0dXJuIGF3YWl0IGdlbmVyYXRlS2V5KHBhc3N3b3JkLCBzYWx0LCBvcHRzLnNjcnlwdCk7XG4gIH1cbiAgaWYgKCFrZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkEga2V5LCBvciBhIHBhc3N3b3JkL3NhbHQgdG8gZ2VuZXJhdGUgYSBrZXkgZnJvbSwgaXMgcmVxdWlyZWQhXCJcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAga2V5ID0gZGVjb2RlVVRGOChrZXkpO1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xuXG5leHBvcnQgY29uc3QgZW5jcnlwdCA9IGFzeW5jIChcbiAgb2JqOiBFbmNyeXB0YWJsZURhdGEsXG4gIHNlY3JldE9wdHM6IFNlY3JldE9wdGlvbnNcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IG5vbmNlID0gc2VjcmV0T3B0cy5ub25jZSB8fCBuZXdOb25jZSgpO1xuICBpZiAobm9uY2UubGVuZ3RoICE9PSBzZWNyZXRib3gubm9uY2VMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBub25jZSwgbXVzdCBiZSBhIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7c2VjcmV0Ym94Lm5vbmNlTGVuZ3RofWBcbiAgICApO1xuICB9XG4gIGNvbnN0IGtleVVpbnQ4QXJyYXkgPSBhd2FpdCBnZXRVaW50OEFycmF5S2V5RnJvbU9wdHMoc2VjcmV0T3B0cyk7XG4gIGNvbnN0IG1lc3NhZ2VVaW50OCA9IGRlY29kZVVURjgoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIGNvbnN0IGJveCA9IHNlY3JldGJveChtZXNzYWdlVWludDgsIG5vbmNlLCBrZXlVaW50OEFycmF5KTtcblxuICBjb25zdCBmdWxsTWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG5vbmNlLmxlbmd0aCArIGJveC5sZW5ndGgpO1xuICBmdWxsTWVzc2FnZS5zZXQobm9uY2UpO1xuICBmdWxsTWVzc2FnZS5zZXQoYm94LCBub25jZS5sZW5ndGgpO1xuXG4gIHJldHVybiBlbmNvZGVCYXNlNjQoZnVsbE1lc3NhZ2UpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY3J5cHQgPSBhc3luYyAoXG4gIG1lc3NhZ2VXaXRoTm9uY2U6IHN0cmluZyxcbiAgc2VjcmV0T3B0czogU2VjcmV0T3B0aW9uc1xuKTogUHJvbWlzZTxFbmNyeXB0YWJsZURhdGE+ID0+IHtcbiAgY29uc3Qga2V5VWludDhBcnJheSA9IGF3YWl0IGdldFVpbnQ4QXJyYXlLZXlGcm9tT3B0cyhzZWNyZXRPcHRzKTtcbiAgY29uc3QgbWVzc2FnZVdpdGhOb25jZUFzVWludDhBcnJheSA9IGRlY29kZUJhc2U2NChtZXNzYWdlV2l0aE5vbmNlKTtcbiAgY29uc3Qgbm9uY2UgPSBtZXNzYWdlV2l0aE5vbmNlQXNVaW50OEFycmF5LnNsaWNlKDAsIHNlY3JldGJveC5ub25jZUxlbmd0aCk7XG4gIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlV2l0aE5vbmNlQXNVaW50OEFycmF5LnNsaWNlKFxuICAgIHNlY3JldGJveC5ub25jZUxlbmd0aCxcbiAgICBtZXNzYWdlV2l0aE5vbmNlLmxlbmd0aFxuICApO1xuXG4gIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBzZWNyZXRib3gub3BlbihtZXNzYWdlLCBub25jZSwga2V5VWludDhBcnJheSk7XG5cbiAgaWYgKCFkZWNyeXB0ZWREYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRlY3J5cHQgbWVzc2FnZVwiKTtcbiAgfVxuXG4gIGNvbnN0IGJhc2U2NERlY3J5cHRlZE1lc3NhZ2UgPSBlbmNvZGVVVEY4KGRlY3J5cHRlZERhdGEpO1xuICByZXR1cm4gSlNPTi5wYXJzZShiYXNlNjREZWNyeXB0ZWRNZXNzYWdlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlbmNyeXB0ZWQgPSBhc3luYyAoXG4gIGRhdGE6IEVuY3J5cHRhYmxlRGF0YSxcbiAgc2VjcmV0T3B0czogRW5jcnlwdGVkT3B0aW9uc1xuKTogUHJvbWlzZTxNYXliZUVuY3J5cHRlZERvY3VtZW50PiA9PiB7XG4gIGlmICh0eXBlb2Ygc2VjcmV0T3B0cy5zYWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgc2VjcmV0T3B0cy5zYWx0ID0gbmV3UmFuZG9tU2FsdCgpO1xuICB9XG4gIGlmIChzZWNyZXRPcHRzLnR5cGUgPT09IFwicGxhaW50ZXh0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW5jcnlwdGlvbjogeyB0eXBlOiBcInBsYWludGV4dFwiIH0sXG4gICAgICBkYXRhOiBkYXRhLFxuICAgIH0gYXMgUGxhaW50ZXh0RG9jdW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVmYXVsdCBpcyB1c2luZyBzZWNyZXRib3hcbiAgICBzZWNyZXRPcHRzLm5vbmNlID0gbmV3Tm9uY2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZW5jcnlwdGlvbjoge1xuICAgICAgICB0eXBlOiBcInNlY3JldGJveFwiLFxuICAgICAgICBzYWx0OiBzZWNyZXRPcHRzLnNhbHQsXG4gICAgICAgIG5vbmNlOiBlbmNvZGVCYXNlNjQoc2VjcmV0T3B0cy5ub25jZSksXG4gICAgICAgIHNjcnlwdDogeyAuLi5sYXRlc3RTY3J5cHRPcHRpb25zIH0sXG4gICAgICB9LFxuICAgICAgZGF0YTogYXdhaXQgZW5jcnlwdChkYXRhLCBzZWNyZXRPcHRzKSxcbiAgICB9IGFzIFNlY3JldGJveEVuY3J5cHRlZERvY3VtZW50O1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGVjcnlwdGVkID0gYXN5bmMgKFxuICBlbmNyeXB0ZWREYXRhOiBNYXliZUVuY3J5cHRlZERvY3VtZW50LFxuICBzZWNyZXRPcHRzOiBTZWNyZXRPcHRpb25zXG4pOiBQcm9taXNlPEVuY3J5cHRhYmxlRGF0YT4gPT4ge1xuICBpZiAoZW5jcnlwdGVkRGF0YS5lbmNyeXB0aW9uLnR5cGUgPT09IFwic2VjcmV0Ym94XCIpIHtcbiAgICByZXR1cm4gZGVjcnlwdChlbmNyeXB0ZWREYXRhLmRhdGEgYXMgc3RyaW5nLCB7XG4gICAgICBzYWx0OiBlbmNyeXB0ZWREYXRhLmVuY3J5cHRpb24uc2FsdCxcbiAgICAgIHBhc3N3b3JkOiBzZWNyZXRPcHRzLnBhc3N3b3JkLFxuICAgICAga2V5OiBzZWNyZXRPcHRzLmtleSxcbiAgICAgIHNjcnlwdDogZW5jcnlwdGVkRGF0YS5lbmNyeXB0aW9uLnNjcnlwdCxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZW5jcnlwdGVkRGF0YS5kYXRhIGFzIEVuY3J5cHRhYmxlRGF0YTtcbiAgfVxufTtcbiJdfQ==